```diff
--- a/src/js/exercises/vocabulary.js
+++ b/src/js/exercises/vocabulary.js
@@ -1,3 +1,6 @@
+import UserProgress from '../user-progress.js';
+import AudioFeedback from '../audio-feedback.js';
+
 // Functions moved to utils.js: shuffleArray, showNoDataMessage, addRandomizeButton
 
 // Data loading functions
@@ -233,13 +236,20 @@
     document.getElementById('check-opposite').addEventListener('click', () => {
         const userAnswer = document.getElementById('opposite-input').value.trim();
         const feedback = document.getElementById('opposite-feedback');
-        if (userAnswer.toLowerCase() === opposite.toLowerCase()) {
+        const isCorrect = userAnswer.toLowerCase() === opposite.toLowerCase();
+        const itemId = word; // 'word' is the current word being practiced
+
+        UserProgress.recordAnswer(isCorrect, itemId, 'vocabulary');
+
+        if (isCorrect) {
+            AudioFeedback.playSuccessSound();
             feedback.innerHTML = `<span class="correct" aria-label="Correct">‚úÖüëè ${t.correct || 'Correct!'}</span>`;
             document.getElementById('opposite-answer').textContent = opposite;
         } else {
+            AudioFeedback.playErrorSound();
             feedback.innerHTML = `<span class="incorrect" aria-label="Incorrect">‚ùåü§î ${t.feedbackNotQuiteTryAgain || 'Try again!'}</span>`;
         }
     });
     document.getElementById('reveal-opposite').addEventListener('click', () => {
         document.getElementById('opposite-answer').textContent = opposite;
@@ -252,6 +262,7 @@
 // Match opposites exercise
 async function showMatchOpposites() {
     const language = document.getElementById('language').value;
+    const t = translations[language] || translations.COSYenglish;
     const days = getSelectedDays();
     
     if (!language || !days.length) {
@@ -273,12 +284,17 @@
     while (selectedPairs.length < 4 && availableWords.length > 0) {
         const randomIndex = Math.floor(Math.random() * availableWords.length);
         const currentWord = availableWords[randomIndex];
-        
-        if (opposites[word]) {
+                
+        if (opposites[currentWord]) {
             selectedPairs.push({
-                word: word,
-                opposite: opposites[word]
+                word: currentWord,
+                opposite: opposites[currentWord]
             });
-            availableWords.splice(randomIndex, 1);
-        }
+        }
+        availableWords.splice(randomIndex, 1); 
+    }
+
+    if (selectedPairs.length < 1) { 
+        showNoDataMessage(); return;
     }
 
     // Shuffle the words and opposites
@@ -303,10 +319,10 @@
                 </div>
             </div>
             <div id="match-feedback" class="exercise-feedback" aria-live="polite"></div>
-            <button id="check-matches" class="btn-primary" aria-label="${t.checkMatches || 'Check Matches'}">‚úÖ ${translations[language]?.check || 'Check'} ${t.matches || 'Matches'}</button>
             <button id="new-match" class="btn-secondary" aria-label="${t.newExercise || 'New Exercise'}">üîÑ ${t.newExercise || 'New Exercise'}</button>
         </div>
     `;
+    // Note: Removed 'check-matches' button as matching is now instant feedback.
 
     // Add matching functionality
     let selectedWord = null;
@@ -314,42 +330,45 @@
 
     document.querySelectorAll('#words-col .match-item').forEach(item => {
         item.addEventListener('click', function() {
+            if (this.classList.contains('matched')) return;
             document.querySelectorAll('.match-item').forEach(i => i.classList.remove('selected'));
             this.classList.add('selected');
             selectedWord = this.getAttribute('data-word');
+            checkOppositeMatchAttempt();
         });
     });
 
     document.querySelectorAll('#opposites-col .match-item').forEach(item => {
         item.addEventListener('click', function() {
-            if (!selectedWord) return;
+            if (this.classList.contains('matched') || !selectedWord) return;
             
             document.querySelectorAll('.match-item').forEach(i => i.classList.remove('selected'));
             this.classList.add('selected');
             selectedOpposite = this.getAttribute('data-opposite');
-            
-            // Check if this is the correct opposite
-            const correctOpposite = opposites[selectedWord];
+            checkOppositeMatchAttempt();
+        });
+    });
+
+    function checkOppositeMatchAttempt() {
+        if (selectedWord && selectedOpposite) {
+            const correctOppositeForWord = opposites[selectedWord];
             const feedback = document.getElementById('match-feedback');
-            
-            if (selectedOpposite === correctOpposite) {
-                feedback.innerHTML = '<span class="correct">‚úÖ Correct match!</span>';
-                document.querySelector(`[data-word="${selectedWord}"]`).classList.add('matched');
-                this.classList.add('matched');
+            const isCorrect = selectedOpposite === correctOppositeForWord;
+
+            UserProgress.recordAnswer(isCorrect, selectedWord, 'vocabulary_match_pair');
+
+            if (isCorrect) {
+                AudioFeedback.playSuccessSound();
+                feedback.innerHTML = `<span class="correct">‚úÖ ${t.correctMatch || 'Correct match!'}</span>`;
+                document.querySelector(`[data-word="${selectedWord}"]`).classList.add('matched').style.pointerEvents = 'none';
+                document.querySelector(`[data-opposite="${selectedOpposite}"]`).classList.add('matched').style.pointerEvents = 'none';
             } else {
-                feedback.innerHTML = '<span class="incorrect">‚ùå Not a match. Try again!</span>';
+                AudioFeedback.playErrorSound();
+                feedback.innerHTML = `<span class="incorrect">‚ùå ${t.notAMatch || 'Not a match. Try again!'}</span>`;
+                document.querySelector(`[data-word="${selectedWord}"]`)?.classList.remove('selected');
+                document.querySelector(`[data-opposite="${selectedOpposite}"]`)?.classList.remove('selected');
             }
-            
             selectedWord = null;
             selectedOpposite = null;
-        });
-    });
-
-    document.getElementById('check-matches').addEventListener('click', () => {
-        // Check all matches
-        const feedback = document.getElementById('match-feedback');
-        feedback.innerHTML = 'Showing all correct matches...';
-        
-        selectedPairs.forEach(pair => {
-            document.querySelector(`[data-word="${pair.word}"]`).classList.add('matched');
-            document.querySelector(`[data-opposite="${pair.opposite}"]`).classList.add('matched');
-        });
-
-        setTimeout(() => {
-            showMatchOpposites();
-        }, 2000);
+        }
+    }
+
+    document.getElementById('new-match').addEventListener('click', () => {
+        showMatchOpposites();
+    });
+}
+
+// Enhanced build word exercise
+async function showBuildWord(baseWord = null) {
+    const language = document.getElementById('language').value;
+    const days = getSelectedDays();
+    const t = translations[language] || translations.COSYenglish;
+    
+    if (!language || !days.length) {
+        alert(t.alertLangDay || 'Please select language and day(s) first');
+        return;
+    }
+
+    const words = await loadVocabulary(language, days);
+    if (!words.length) {
+        showNoDataMessage();
+        return;
+    }
+
+    const word = baseWord || words[Math.floor(Math.random() * words.length)]; // 'word' is itemId
+    const shuffledLetters = shuffleArray([...word.toLowerCase()]);
+        
+    const resultArea = document.getElementById('result');
+    resultArea.innerHTML = `
+        <div class="build-word-exercise">
+            <div class="letter-pool" id="letter-pool">
+                ${shuffledLetters.map((letter, index) => `
+                    <div class="letter-tile" data-letter="${letter}" draggable="true">${letter}</div>
+                `).join('')}
+            </div>
+            <div class="word-slots" id="word-slots">
+                ${Array(word.length).fill().map(() => `
+                    <div class="letter-slot"></div>
+                `).join('')}
+            </div>
+            <div id="build-feedback"></div>
+            <div class="build-actions">
+                <button id="check-build" class="btn-primary">${translations[language]?.buttons?.check || 'Check'}</button>
+                <button id="reset-build" class="btn-secondary">${translations[language]?.buttons?.reset || 'Reset'}</button>
+                <button id="new-build" class="btn-secondary">üîÑ ${t.buttons?.newWord || 'New Word'}</button>
+            </div>
+        </div>
+    `;
+
+    const letterTiles = document.querySelectorAll('.letter-tile');
+    const letterSlots = document.querySelectorAll('.letter-slot');
+    
+    letterTiles.forEach(tile => {
+        tile.addEventListener('dragstart', dragStart);
+    });
+
+    letterSlots.forEach(slot => {
+        slot.addEventListener('dragover', dragOver);
+        slot.addEventListener('drop', drop);
+        slot.addEventListener('dragenter', dragEnter);
+        slot.addEventListener('dragleave', dragLeave);
+    });
+
+    document.getElementById('check-build').addEventListener('click', () => {
+        const builtWord = [...document.querySelectorAll('.letter-slot')]
+            .map(slot => slot.textContent)
+            .join('');
+        const feedback = document.getElementById('build-feedback');
+        const isCorrect = builtWord.toLowerCase() === word.toLowerCase();
+
+        UserProgress.recordAnswer(isCorrect, word, 'vocabulary');
+        
+        if (isCorrect) {
+            AudioFeedback.playSuccessSound();
+            feedback.innerHTML = `<span class="correct">‚úÖ ${t.correctWellDone || 'Correct! Well done!'}</span>`;
+        } else {
+            AudioFeedback.playErrorSound();
+            feedback.innerHTML = `<span class="incorrect">‚ùå ${t.notQuiteKeepTrying || 'Not quite. Keep trying!'}</span>`;
+        }
+    });
+
+    document.getElementById('reset-build').addEventListener('click', () => {
+        const pool = document.getElementById('letter-pool');
+        const slots = document.querySelectorAll('.letter-slot');
+        
+        slots.forEach(slot => {
+            if (slot.firstChild) {
+                pool.appendChild(slot.firstChild);
+                slot.firstChild.classList.remove('dragging'); 
+            }
+        });
+        document.getElementById('build-feedback').innerHTML = '';
+    });
+
+    document.getElementById('new-build').addEventListener('click', () => {
+        showBuildWord();
+    });
+}
+
+// Drag and drop functions for build word exercise
+function dragStart(e) {
+    e.dataTransfer.setData('text/plain', e.target.dataset.letter);
+    e.dataTransfer.setData('sourceElementId', e.target.id || `tile-${Date.now()}-${Math.random()}`);
+    e.target.classList.add('dragging');
+}
+
+function dragOver(e) {
+    e.preventDefault();
+}
+
+function drop(e) {
+    e.preventDefault();
+    const sourceElementId = e.dataTransfer.getData('sourceElementId');
+    let draggingElement = document.getElementById(sourceElementId);
+    if (!draggingElement) draggingElement = document.querySelector('.letter-tile.dragging');
+
+    if (e.target.classList.contains('letter-slot')) {
+        if (e.target.firstChild) {
+            const pool = document.getElementById('letter-pool'); 
+            pool.appendChild(e.target.firstChild);
+        }
+        if(draggingElement) e.target.appendChild(draggingElement);
+    } else if (e.target.classList.contains('letter-pool')) { 
+         if(draggingElement) e.target.appendChild(draggingElement);
+    }
+    if(draggingElement) draggingElement.classList.remove('dragging');
+}
+
+function dragEnter(e) {
+    e.preventDefault();
+    if (e.target.classList.contains('letter-slot') || e.target.classList.contains('letter-pool')) {
+        e.target.classList.add('hovered');
+    }
+}
+
+function dragLeave(e) {
+    if (e.target.classList.contains('letter-slot') || e.target.classList.contains('letter-pool')) {
+        e.target.classList.remove('hovered');
+    }
+}
+
+// Random image practice
+async function startRandomImagePractice() {
+    const exercises = VOCABULARY_PRACTICE_TYPES['random-image'].exercises;
+    const randomExercise = exercises[Math.floor(Math.random() * exercises.length)];
+    
+    switch(randomExercise) {
+        case 'identify-image':
+            await showIdentifyImage();
+            break;
+        case 'match-image-word':
+            await showMatchImageWord();
+            break;
+    }
+}
+
+// Identify image exercise
+async function showIdentifyImage() {
+    const language = document.getElementById('language').value;
+    const days = getSelectedDays();
+    const t = translations[language] || translations.COSYenglish;
+    
+    if (!language || !days.length) {
+        alert(t.alertLangDay || 'Please select language and day(s) first');
+        return;
+    }
+
+    const images = await loadImageVocabulary(language, days);
+    if (!images.length) {
+        showNoDataMessage();
+        return;
+    }
+
+    const imageItem = images[Math.floor(Math.random() * images.length)];
+    const correctAnswer = imageItem.translations[language];
+    const itemId = imageItem.id || correctAnswer; // Use imageItem.id or the word itself as ID
+    
+    const resultArea = document.getElementById('result');
+    resultArea.innerHTML = `
+        <div class="image-exercise">
+            <h3>üñºÔ∏è ${t.whatIsThis || 'What is this?'}</h3>
+            <img src="${imageItem.src}" alt="${imageItem.alt}" class="vocabulary-image">
+            <input type="text" id="image-answer" placeholder="${t.typeTheWord || 'Type the word...'}">
+            <button id="check-image" class="btn-primary">${translations[language]?.buttons?.check || 'Check'}</button>
+            <div id="image-feedback"></div>
+            <button id="new-image" class="btn-secondary">üîÑ ${t.buttons?.newWord || 'New Word'}</button>
+        </div>
+    `;
+
+    addEnterKeySupport('image-answer', 'check-image');
+
+    document.getElementById('check-image').addEventListener('click', () => {
+        const userAnswer = document.getElementById('image-answer').value.trim();
+        const feedback = document.getElementById('image-feedback');
+        const isCorrect = userAnswer.toLowerCase() === correctAnswer.toLowerCase();
+        
+        UserProgress.recordAnswer(isCorrect, itemId, 'vocabulary');
+
+        if (isCorrect) {
+            AudioFeedback.playSuccessSound();
+            feedback.innerHTML = `<span class="correct" aria-label="Correct">‚úÖüëè ${t.correct || 'Correct!'}</span>`;
+        } else {
+            AudioFeedback.playErrorSound();
+            feedback.innerHTML = `<span class="incorrect" aria-label="Incorrect">‚ùåü§î ${t.feedbackNotQuiteTryAgain || 'Not quite. Try again!'}</span>`;
+        }
+    });
+
+    document.getElementById('new-image').addEventListener('click', () => {
+        showIdentifyImage();
+    });
+}
+
+// Match image with word exercise
+async function showMatchImageWord() {
+    const language = document.getElementById('language').value;
+    const days = getSelectedDays();
+    const t = translations[language] || translations.COSYenglish;
+    
+    if (!language || !days.length) {
+        alert(t.alertLangDay || 'Please select language and day(s) first');
+        return;
+    }
+
+    const imagesData = await loadImageVocabulary(language, days); 
+    let wordsData = await loadVocabulary(language, days); 
+    
+    if (imagesData.length < 4 || wordsData.length < 4) {
+        showNoDataMessage();
+        return;
+    }
+
+    let selectedImageItems = [];
+    const availableImages = [...imagesData];
+    while(selectedImageItems.length < 4 && availableImages.length > 0) {
+        const randIdx = Math.floor(Math.random() * availableImages.length);
+        selectedImageItems.push(availableImages[randIdx]);
+        availableImages.splice(randIdx, 1);
+    }
+    if (selectedImageItems.length < 1) {
+         showNoDataMessage(); return;
+    }
+
+    const correctWordsForImages = selectedImageItems.map(img => img.translations[language]);
+    let displayWords = [...correctWordsForImages];
+    let wordPool = wordsData.filter(w => !correctWordsForImages.includes(w)); 
+    
+    while (displayWords.length < Math.min(8, selectedImageItems.length * 2) && wordPool.length > 0) { // Aim for up to 8 total items (4 images + 4 words or fewer if not enough unique words)
+        const randIdx = Math.floor(Math.random() * wordPool.length);
+        if (!displayWords.includes(wordPool[randIdx])) {
+             displayWords.push(wordPool[randIdx]);
+        }
+        wordPool.splice(randIdx,1); // Remove to avoid re-picking
+    }
+    
+    let displayItems = [];
+    selectedImageItems.forEach(imgItm => {
+        displayItems.push({
+            type: 'image',
+            src: imgItm.src,
+            alt: imgItm.alt,
+            answer: imgItm.translations[language],
+            id: imgItm.id || imgItm.translations[language] // Use image id or the answer as id
+        });
+    });
+    shuffleArray(displayWords).forEach(w => { // Shuffle words before adding to ensure randomness
+         displayItems.push({ type: 'word', text: w, id: w }); // Word itself as id for word items
+    });
+
+    const shuffledDisplayItems = shuffleArray(displayItems);
+
+    const resultArea = document.getElementById('result');
+    resultArea.innerHTML = `
+        <div class="match-image-word-exercise">
+            <h3>üñºÔ∏è ${t.matchEachImageWithWord || 'Match each image with its word'}</h3>
+            <div class="match-grid">
+                ${shuffledDisplayItems.map(item => `
+                    ${item.type === 'image' ? `
+                        <div class="match-item image-item" data-answer="${item.answer}" data-id="${item.id}">
+                            <img src="${item.src}" alt="${item.alt}">
+                        </div>
+                    ` : `
+                        <div class="match-item word-item" data-word="${item.text}" data-id="${item.id}">
+                            ${item.text}
+                        </div>
+                    `}
+                `).join('')}
+            </div>
+            <div id="match-image-feedback"></div>
+            <button id="new-image-match" class="btn-secondary" aria-label="${t.newExercise || 'New Exercise'}">üîÑ ${t.newExercise || 'New Exercise'}</button>
+        </div>
+    `;
+    // Removed check-image-matches button as matching is now instant feedback
+
+    let selectedImageElement = null;
+    let selectedWordElement = null;
+
+    document.querySelectorAll('.image-item').forEach(item => {
+        item.addEventListener('click', function() {
+            if(this.classList.contains('matched')) return;
+            if(selectedImageElement) selectedImageElement.classList.remove('selected');
+            this.classList.add('selected');
+            selectedImageElement = this;
+            checkImageWordMatchAttempt();
+        });
+    });
+
+    document.querySelectorAll('.word-item').forEach(item => {
+        item.addEventListener('click', function() {
+            if(this.classList.contains('matched')) return;
+             if(selectedWordElement) selectedWordElement.classList.remove('selected'); // Allow changing word selection
+            this.classList.add('selected');
+            selectedWordElement = this;
+            checkImageWordMatchAttempt();
+        });
+    });
+
+    function checkImageWordMatchAttempt() {
+        if (selectedImageElement && selectedWordElement) {
+            const imageAnswer = selectedImageElement.getAttribute('data-answer');
+            const imageId = selectedImageElement.getAttribute('data-id'); // Use image's own ID
+            const wordText = selectedWordElement.getAttribute('data-word');
+            const feedback = document.getElementById('match-image-feedback');
+            const isCorrect = imageAnswer === wordText;
+
+            UserProgress.recordAnswer(isCorrect, imageId, 'vocabulary_match_image');
+
+            if (isCorrect) {
+                AudioFeedback.playSuccessSound();
+                feedback.innerHTML = `<span class="correct">‚úÖ ${t.correctMatch || 'Correct match!'}</span>`;
+                selectedImageElement.classList.add('matched');
+                selectedWordElement.classList.add('matched');
+                selectedImageElement.style.pointerEvents = 'none';
+                selectedWordElement.style.pointerEvents = 'none';
+            } else {
+                AudioFeedback.playErrorSound();
+                feedback.innerHTML = `<span class="incorrect">‚ùå ${t.notAMatch || 'Not a match. Try again!'}</span>`;
+                 // Don't make them unclickable, just deselect
+                if(selectedImageElement) selectedImageElement.classList.remove('selected');
+                if(selectedWordElement) selectedWordElement.classList.remove('selected');
+            }
+            selectedImageElement = null;
+            selectedWordElement = null;
+        }
+    }
+
+    document.getElementById('new-image-match').addEventListener('click', () => {
+        showMatchImageWord();
+    });
+}
+
+// Listening practice
+async function startListeningPractice() {
+    const exercises = VOCABULARY_PRACTICE_TYPES['listening'].exercises;
+    const randomExercise = exercises[Math.floor(Math.random() * exercises.length)];
+    
+    switch(randomExercise) {
+        case 'transcribe-word':
+            await showTranscribeWord();
+            break;
+        case 'match-sound-word':
+            await showMatchSoundWord();
+            break;
+    }
+}
+
+// Transcribe word exercise
+async function showTranscribeWord() {
+    const language = document.getElementById('language').value;
+    const days = getSelectedDays();
+    const t = translations[language] || translations.COSYenglish;
+    
+    if (!language || !days.length) {
+        alert(t.alertLangDay || 'Please select language and day(s) first');
+        return;
+    }
+
+    const words = await loadVocabulary(language, days);
+    if (!words.length) {
+        showNoDataMessage();
+        return;
+    }
+
+    const word = words[Math.floor(Math.random() * words.length)]; // 'word' is itemId
+    const resultArea = document.getElementById('result');
+    
+    resultArea.innerHTML = `
+        <div class="listening-exercise">
+            <button id="play-word" class="btn-emoji">üîä</button>
+            <input type="text" id="transcription" placeholder="${t.typeWhatYouHear || 'Type what you hear...'}">
+            <button id="check-transcription" class="btn-primary">${translations[language]?.buttons?.check || 'Check'}</button>
+            <div id="transcription-feedback"></div>
+            <button id="new-transcription" class="btn-secondary">üîÑ ${t.buttons?.newWord || 'New Word'}</button>
+        </div>
+    `;
+    addEnterKeySupport('transcription', 'check-transcription');
+
+    document.getElementById('play-word').addEventListener('click', () => {
+        pronounceWord(word, language);
+    });
+
+    document.getElementById('check-transcription').addEventListener('click', () => {
+        const userAnswer = document.getElementById('transcription').value.trim();
+        const feedback = document.getElementById('transcription-feedback');
+        const isCorrect = userAnswer.toLowerCase() === word.toLowerCase();
+        
+        UserProgress.recordAnswer(isCorrect, word, 'vocabulary');
+
+        if (isCorrect) {
+            AudioFeedback.playSuccessSound();
+            feedback.innerHTML = `<span class="correct">‚úÖ ${t.correctWellDone || 'Correct! Well done!'}</span>`;
+        } else {
+            AudioFeedback.playErrorSound();
+            feedback.innerHTML = `<span class="incorrect">‚ùå ${t.notQuiteKeepTrying || 'Not quite. Keep trying!'}</span>`;
+        }
+    });
+
+    document.getElementById('new-transcription').addEventListener('click', () => {
+        showTranscribeWord();
+    });
+}
+
+// Match sound with word exercise
+async function showMatchSoundWord() {
+    const language = document.getElementById('language').value;
+    const days = getSelectedDays();
+    const t = translations[language] || translations.COSYenglish;
+    
+    if (!language || !days.length) {
+        alert(t.alertLangDay || 'Please select language and day(s) first');
+        return;
+    }
+
+    const words = await loadVocabulary(language, days);
+    if (words.length < 4) {
+        showNoDataMessage();
+        return;
+    }
+
+    const selectedWords = shuffleArray([...words]).slice(0, 4); // Ensure 4 unique words
+    const wordToPlay = selectedWords[Math.floor(Math.random() * selectedWords.length)]; // 'wordToPlay' is itemId
+    
+    const resultArea = document.getElementById('result');
+    resultArea.innerHTML = `
+        <div class="match-sound-exercise">
+            <button id="play-target-word" class="btn-emoji large">üîä</button>
+            <div class="word-options">
+                ${selectedWords.map(wordItem => `
+                    <button class="word-option" data-word="${wordItem}">${wordItem}</button>
+                `).join('')}
+            </div>
+            <div id="sound-match-feedback"></div>
+            <button id="new-sound-match" class="btn-secondary">${translations[language]?.buttons?.newExercise || 'New Exercise'}</button>
+        </div>
+    `;
+
+    document.getElementById('play-target-word').addEventListener('click', () => {
+        pronounceWord(wordToPlay, language);
+    });
+
+    document.querySelectorAll('.word-option').forEach(option => {
+        option.addEventListener('click', function() {
+            const selectedWordValue = this.getAttribute('data-word');
+            const feedback = document.getElementById('sound-match-feedback');
+            const isCorrect = selectedWordValue === wordToPlay;
+
+            document.querySelectorAll('.word-option').forEach(btn => btn.disabled = true); // Disable after one choice
+            
+            UserProgress.recordAnswer(isCorrect, wordToPlay, 'vocabulary');
+
+            if (isCorrect) {
+                AudioFeedback.playSuccessSound();
+                feedback.innerHTML = `<span class="correct">‚úÖ ${t.correctWellDone || 'Correct! Well done!'}</span>`;
+                this.classList.add('correct');
+            } else {
+                AudioFeedback.playErrorSound();
+                feedback.innerHTML = `<span class="incorrect">‚ùå ${t.notCorrect || 'Not correct.'} ${t.correctAnswerWas || 'The correct answer was'}: ${wordToPlay}</span>`;
+                this.classList.add('incorrect');
+                document.querySelector(`.word-option[data-word="${wordToPlay}"]`)?.classList.add('correct'); // Highlight correct one
+            }
+        });
+    });
+
+    document.getElementById('new-sound-match').addEventListener('click', () => {
+        showMatchSoundWord();
+    });
+}
+
+// Practice all vocabulary exercises
+async function practiceAllVocabulary() {
+    const language = document.getElementById('language').value;
+    const days = getSelectedDays();
+    const t = translations[language] || translations.COSYenglish;
+    
+    if (!language || !days.length) {
+        alert(t.alertLangDay || 'Please select language and day(s) first');
+        return;
+    }
+
+    const allExercises = [
+        'random-word', 'random-image', 'listening'
+    ];
+    const shuffledExercises = shuffleArray(allExercises);
+    
+    for (const exercise of shuffledExercises) {
+        // ... (existing switch case for calling exercises)
+        switch(exercise) {
+            case 'random-word':
+                await startRandomWordPractice();
+                break;
+            case 'random-image':
+                await startRandomImagePractice();
+                break;
+            case 'listening':
+                await startListeningPractice();
+                break;
+        }
+        
+        await new Promise(resolve => {
+            const resultArea = document.getElementById('result');
+            if (!resultArea) { // Should not happen
+                resolve(); return;
+            }
+            
+            let continuePrompt = resultArea.querySelector('.continue-prompt');
+            if (continuePrompt) continuePrompt.remove(); // Remove old prompt if any
+
+            continuePrompt = document.createElement('div');
+            continuePrompt.className = 'continue-prompt exercise-feedback'; // Added exercise-feedback for consistent styling
+            
+            const p = document.createElement('p');
+            p.textContent = t.pressContinueNextExercise || 'Press continue for next exercise';
+            continuePrompt.appendChild(p);
+
+            const continueBtn = document.createElement('button');
+            continueBtn.className = 'btn-primary margin-top-10'; // Added margin for spacing
+            continueBtn.textContent = t.buttons?.continue || 'Continue';
+            
+            const uniqueId = 'continue-btn-' + Date.now();
+            continueBtn.id = uniqueId;
+
+            continueBtn.addEventListener('click', () => {
+                resolve();
+                if(continuePrompt) continuePrompt.remove();
+            }, { once: true }); // Ensure listener is removed after click
+            
+            continuePrompt.appendChild(continueBtn);
+            resultArea.appendChild(continuePrompt);
+        });
+    }
+     // After all exercises, show a completion message or return to menu
+    const resultArea = document.getElementById('result');
+    if (resultArea) {
+        resultArea.innerHTML += `<p class="exercise-feedback">${t.allVocabularyPracticed || 'All vocabulary exercises for this selection completed!'}</p>`;
+    }
+}
+
+// Helper functions
+function shuffleArray(array) {
+    const newArray = [...array];
+    for (let i = newArray.length - 1; i > 0; i--) {
+        const j = Math.floor(Math.random() * (i + 1));
+        [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
+    }
+    return newArray;
+}
+
+function showNoDataMessage() {
+    const resultArea = document.getElementById('result');
+    const lang = document.getElementById('language')?.value;
+    const t = translations[lang] || translations.COSYenglish;
+    resultArea.innerHTML = `<p class="no-data">${t.noDataAvailable || 'No data available for selected day/language.'}</p>`;
+}
+
+// Patch all main vocabulary exercise renderers for randomize button and unified container
+showRandomWord = patchExerciseForRandomizeButton(showRandomWord, '.word-display-container', startRandomWordPractice);
+showOppositesExercise = patchExerciseForRandomizeButton(showOppositesExercise, '.opposites-exercise', startRandomWordPractice);
+showMatchOpposites = patchExerciseForRandomizeButton(showMatchOpposites, '.match-exercise', startRandomWordPractice);
+showBuildWord = patchExerciseForRandomizeButton(showBuildWord, '.build-word-exercise', startRandomWordPractice);
+showIdentifyImage = patchExerciseForRandomizeButton(showIdentifyImage, '.image-exercise', startRandomImagePractice);
+showMatchImageWord = patchExerciseForRandomizeButton(showMatchImageWord, '.match-image-word-exercise', startRandomImagePractice);
+showTranscribeWord = patchExerciseForRandomizeButton(showTranscribeWord, '.listening-exercise', startListeningPractice);
+showMatchSoundWord = patchExerciseForRandomizeButton(showMatchSoundWord, '.match-sound-exercise', startListeningPractice);
+
+// --- PATCH: Always include required pairs for day 1 in match opposites and match image-word ---
+const REQUIRED_DAY1_OPPOSITES = [
+    { base: 'hello', opposite: 'goodbye' },
+    { base: 'yes', opposite: 'no' },
+    { base: 'thank you', opposite: "you're welcome" }
+];
+
+// Helper to get translations for required pairs in current language
+async function getRequiredDay1Pairs(language) {
+    const words = await loadVocabulary(language, '1');
+    const opposites = await loadOpposites(language, '1'); 
+    let pairs = [];
+
+    for (const req of REQUIRED_DAY1_OPPOSITES) {
+        let baseWord = words.find(w => w.toLowerCase() === req.base.toLowerCase());
+        let oppWord = null;
+
+        if (baseWord) { 
+            if (opposites[baseWord]) {
+                oppWord = opposites[baseWord];
+            } else {
+                oppWord = words.find(w => w.toLowerCase() === req.opposite.toLowerCase());
+            }
+        }
+        
+        if (baseWord && oppWord) {
+             pairs.push({
+                word: baseWord,
+                opposite: oppWord
+            });
+        }
+    }
+    return pairs;
+}
+
+// PATCH showMatchOpposites
+const _origShowMatchOpposites = showMatchOpposites;
+showMatchOpposites = async function() {
+    const language = document.getElementById('language').value;
+    const days = getSelectedDays();
+    const t = translations[language] || translations.COSYenglish;
+
+    if (days && days.includes('1')) {
+        const words = await loadVocabulary(language, days); 
+        const oppositesData = await loadOpposites(language, days); 
+        
+        let selectedPairs = await getRequiredDay1Pairs(language); 
+
+        const availableWordsForRandom = [...words].filter(w => 
+            !selectedPairs.some(p => p.word === w) && oppositesData[w]
+        );
+        
+        while (selectedPairs.length < 4 && availableWordsForRandom.length > 0) {
+            const randomIndex = Math.floor(Math.random() * availableWordsForRandom.length);
+            const word = availableWordsForRandom[randomIndex];
+            selectedPairs.push({ word, opposite: oppositesData[word] });
+            availableWordsForRandom.splice(randomIndex, 1);
+        }
+         if (selectedPairs.length === 0) { showNoDataMessage(); return; }
+
+
+        const wordsColumn = shuffleArray(selectedPairs.map(p => p.word));
+        const oppositesColumn = shuffleArray(selectedPairs.map(p => p.opposite));
+        
+        const resultArea = document.getElementById('result');
+        resultArea.innerHTML = `
+            <div class="match-exercise" role="region" aria-label="${t.matchOppositesExercise || 'Match Opposites Exercise'}">
+                <div class="match-container">
+                    <div class="match-col" id="words-col" aria-label="${t.wordsColumn || 'Words column'}">
+                        ${wordsColumn.map(word => `
+                            <div class="match-item" data-word="${word}" role="button" tabindex="0" aria-label="${t.wordLabel || 'Word'}: ${word}">${word}</div>
+                        `).join('')}
+                    </div>
+                    <div class="match-col" id="opposites-col" aria-label="${t.oppositesColumn || 'Opposites column'}">
+                        ${oppositesColumn.map(opposite => `
+                            <div class="match-item" data-opposite="${opposite}" role="button" tabindex="0" aria-label="${t.oppositeLabel || 'Opposite'}: ${opposite}">${opposite}</div>
+                        `).join('')}
+                    </div>
+                </div>
+                <div id="match-feedback" class="exercise-feedback" aria-live="polite"></div>
+                <button id="new-match" class="btn-secondary" aria-label="${t.newExercise || 'New Exercise'}">üîÑ ${t.newExercise || 'New Exercise'}</button>
+            </div>
+        `;
+        
+        let selectedWordElement = null;
+        // Modified to use the new opposites (from the closure) instead of global `opposites`
+        const currentOppositesMap = selectedPairs.reduce((acc, p) => { acc[p.word] = p.opposite; return acc; }, {});
+
+
+        document.querySelectorAll('#words-col .match-item').forEach(item => {
+            item.addEventListener('click', function() {
+                if(this.classList.contains('matched')) return;
+                if(selectedWordElement) selectedWordElement.classList.remove('selected');
+                this.classList.add('selected');
+                selectedWordElement = this;
+                checkOppositeMatchAttemptDay1();
+            });
+        });
+        document.querySelectorAll('#opposites-col .match-item').forEach(item => {
+            item.addEventListener('click', function() {
+                 if (this.classList.contains('matched') || !selectedWordElement) return;
+                // if(selectedOppositeElement) selectedOppositeElement.classList.remove('selected'); // Not needed if only one opposite can be selected
+                this.classList.add('selected'); // Visually select the opposite
+                // selectedOppositeElement = this; // Store it if needed for more complex logic
+                checkOppositeMatchAttemptDay1(this); // Pass the clicked opposite element
+            });
+        });
+
+        function checkOppositeMatchAttemptDay1(selectedOppositeElement = null) {
+            if (selectedWordElement && selectedOppositeElement) {
+                const currentWordValue = selectedWordElement.getAttribute('data-word');
+                const currentOppositeValue = selectedOppositeElement.getAttribute('data-opposite');
+                const correctPair = selectedPairs.find(p => p.word === currentWordValue);
+                const feedback = document.getElementById('match-feedback');
+                const isCorrect = correctPair && correctPair.opposite === currentOppositeValue;
+
+                UserProgress.recordAnswer(isCorrect, currentWordValue, 'vocabulary_match_pair_day1');
+
+                if (isCorrect) {
+                    AudioFeedback.playSuccessSound();
+                    feedback.innerHTML = `<span class="correct">‚úÖ ${t.correctMatch || 'Correct match!'}</span>`;
+                    selectedWordElement.classList.add('matched');
+                    selectedOppositeElement.classList.add('matched');
+                    selectedWordElement.style.pointerEvents = 'none';
+                    selectedOppositeElement.style.pointerEvents = 'none';
+                } else {
+                    AudioFeedback.playErrorSound();
+                    feedback.innerHTML = `<span class="incorrect">‚ùå ${t.notAMatch || 'Not a match. Try again!'}</span>`;
+                }
+                if(selectedWordElement) selectedWordElement.classList.remove('selected');
+                if(selectedOppositeElement) selectedOppositeElement.classList.remove('selected'); // Deselect after attempt
+                selectedWordElement = null;
+                // selectedOppositeElement = null; // Reset if needed
+            }
+        }
+        document.getElementById('new-match').addEventListener('click', () => showMatchOpposites());
+        return; 
+    }
+    await _origShowMatchOpposites.apply(this, arguments); // Call original if not Day 1
+};
+
+// PATCH showMatchImageWord
+const _origShowMatchImageWord = showMatchImageWord;
+showMatchImageWord = async function() {
+    const language = document.getElementById('language').value;
+    const days = getSelectedDays();
+    const t = translations[language] || translations.COSYenglish;
+
+    if (days && days.includes('1')) {
+        const allImagesForDays = await loadImageVocabulary(language, days);
+        const allWordsForDays = await loadVocabulary(language, days);
+
+        let requiredImagePairs = []; // Store {src, alt, answer, id}
+        for (const req of REQUIRED_DAY1_OPPOSITES) { 
+            const imageItem = allImagesForDays.find(img => img.translations && img.translations[language] && img.translations[language].toLowerCase() === req.base.toLowerCase());
+            if (imageItem) {
+                requiredImagePairs.push({
+                    src: imageItem.src,
+                    alt: imageItem.alt,
+                    answer: imageItem.translations[language],
+                    id: imageItem.id || imageItem.translations[language] // Use image id or the answer as id
+                });
+            }
+        }
+        
+        let displayImages = [...requiredImagePairs];
+        const availableImagesForRandom = allImagesForDays.filter(img => 
+            img.translations && img.translations[language] && !displayImages.some(p => p.answer === img.translations[language])
+        );
+
+        while (displayImages.length < 4 && availableImagesForRandom.length > 0) {
+            const randomIndex = Math.floor(Math.random() * availableImagesForRandom.length);
+            const img = availableImagesForRandom[randomIndex];
+            displayImages.push({ src: img.src, alt: img.alt, answer: img.translations[language], id: img.id || img.translations[language] });
+            availableImagesForRandom.splice(randomIndex, 1);
+        }
+        if (displayImages.length === 0) { showNoDataMessage(); return; }
+
+
+        let displayWords = displayImages.map(img => img.answer); 
+        const availableWordsForDistractors = allWordsForDays.filter(w => !displayWords.includes(w));
+        
+        while (displayWords.length < (displayImages.length + 4) && displayWords.length < 8 && availableWordsForDistractors.length > 0) { // Ensure enough distractors
+           const randIdx = Math.floor(Math.random() * availableWordsForDistractors.length);
+            if (!displayWords.includes(availableWordsForDistractors[randIdx])) {
+                 displayWords.push(availableWordsForDistractors[randIdx]);
+            }
+            availableWordsForDistractors.splice(randIdx,1);
+        }
+
+        let displayItems = [];
+        displayImages.forEach(imgData => displayItems.push({ type: 'image', ...imgData }));
+        shuffleArray(displayWords).forEach(w => displayItems.push({ type: 'word', text: w, id: w })); // Use word as its own ID for simplicity here
+        
+        const shuffledDisplayItems = shuffleArray(displayItems);
+
+        const resultArea = document.getElementById('result');
+        resultArea.innerHTML = `
+            <div class="match-image-word-exercise">
+                <h3>üñºÔ∏è ${t.matchEachImageWithWord || 'Match each image with its word'}</h3>
+                <div class="match-grid">
+                    ${shuffledDisplayItems.map(item => 
+                        item.type === 'image' ? 
+                        `<div class="match-item image-item" data-answer="${item.answer}" data-id="${item.id}"><img src="${item.src}" alt="${item.alt}"></div>` :
+                        `<div class="match-item word-item" data-word="${item.text}" data-id="${item.id}">${item.text}</div>`
+                    ).join('')}
+                </div>
+                <div id="match-image-feedback"></div>
+                <button id="new-image-match" class="btn-secondary" aria-label="${t.newExercise || 'New Exercise'}">üîÑ ${t.newExercise || 'New Exercise'}</button>
+            </div>
+        `;
+        
+        let selectedImageElement = null;
+        let selectedWordElement = null;
+
+        document.querySelectorAll('.image-item').forEach(item => {
+            item.addEventListener('click', function() {
+                if(this.classList.contains('matched')) return;
+                if(selectedImageElement) selectedImageElement.classList.remove('selected');
+                this.classList.add('selected');
+                selectedImageElement = this;
+                checkImageWordMatchAttemptDay1();
+            });
+        });
+        document.querySelectorAll('.word-item').forEach(item => {
+            item.addEventListener('click', function() {
+                if(this.classList.contains('matched')) return;
+                 if(selectedWordElement) selectedWordElement.classList.remove('selected');
+                this.classList.add('selected');
+                selectedWordElement = this;
+                checkImageWordMatchAttemptDay1();
+            });
+        });
+
+        function checkImageWordMatchAttemptDay1() {
+            if (selectedImageElement && selectedWordElement) {
+                const imageAnswer = selectedImageElement.getAttribute('data-answer');
+                const imageId = selectedImageElement.getAttribute('data-id'); // Use image's own ID
+                const wordText = selectedWordElement.getAttribute('data-word');
+                const feedback = document.getElementById('match-image-feedback');
+                const isCorrect = imageAnswer === wordText;
+
+                UserProgress.recordAnswer(isCorrect, imageId, 'vocabulary_match_image_day1');
+
+                if (isCorrect) {
+                    AudioFeedback.playSuccessSound();
+                    feedback.innerHTML = `<span class="correct">‚úÖ ${t.correctMatch || 'Correct match!'}</span>`;
+                    selectedImageElement.classList.add('matched');
+                    selectedWordElement.classList.add('matched');
+                    selectedImageElement.style.pointerEvents = 'none';
+                    selectedWordElement.style.pointerEvents = 'none';
+                } else {
+                    AudioFeedback.playErrorSound();
+                    feedback.innerHTML = `<span class="incorrect">‚ùå ${t.notAMatch || 'Not a match. Try again!'}</span>`;
+                }
+                if(selectedImageElement) selectedImageElement.classList.remove('selected');
+                if(selectedWordElement) selectedWordElement.classList.remove('selected');
+                selectedImageElement = null;
+                selectedWordElement = null;
+            }
+        }
+        document.getElementById('new-image-match').addEventListener('click', () => showMatchImageWord());
+        return; 
+    }
+    await _origShowMatchImageWord.apply(this, arguments); // Call original if not Day 1
+};
+
+document.addEventListener('DOMContentLoaded', initVocabularyPractice);
